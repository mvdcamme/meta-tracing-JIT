#lang racket

(require racket/date)

(require (file "../slip tracing interpreter.scm"))

(define BENCHMARK_INPUT_PATH "input_file.scm")

;
; Output file
;

(define BASE_OUTPUT_FILE_NAME "./Benchmarking output/output")
(define BASE_OUTPUT_EXTENSION "txt")

(define (make-full-output-file-name)
  (let ((name-datetime-separator " "))
    (define (make-datetime-file-name-part)
      (let* ((seconds (current-seconds))
             (date (seconds->date seconds #t))
             (colon-replace-string ""))
        (date-display-format 'iso-8601)
        (let ((basic-string (date->string date #t)))
          (string-replace basic-string ":" colon-replace-string))))
    (string-append BASE_OUTPUT_FILE_NAME name-datetime-separator (make-datetime-file-name-part) "." BASE_OUTPUT_EXTENSION)))

(define OUTPUT_FILE_NAME (make-full-output-file-name))

(define (write-to-output-file text)
  (let* ((output-file (open-output-file OUTPUT_FILE_NAME #:exists 'append)))
    (display text output-file)
    (close-output-port output-file)))


;
; Interpreters
;
(define rec-slip-interpreter-normal-path "slip interpreters/base rec interpreter.scm")
(define rec-slip-interpreter-traced-path "slip interpreters/traced rec interpreter merging.scm")
(define rec-slip-interpreter-traced-merging-duplication-path "slip interpreters/traced rec interpreter merging duplication.scm")
(define rec-slip-interpreter-traced-no-merging-duplication-path "slip interpreters/traced rec interpreter duplication no merging.scm")

(define rec-slip-interpreter-normal-exp (file->value rec-slip-interpreter-normal-path))
(define rec-slip-interpreter-traced-exp (file->value rec-slip-interpreter-traced-path))
(define rec-slip-interpreter-traced-merging-duplication-exp (file->value rec-slip-interpreter-traced-merging-duplication-path))
(define rec-slip-interpreter-traced-no-merging-duplication-exp (file->value rec-slip-interpreter-traced-no-merging-duplication-path))

;
; Benchmarks
;
(define bubble-sort-benchmark-path "bubble-sort.scm")
(define blur-benchmark-path "blur.scm")
(define boyer-benchmark-path "boyer.scm")
(define browse-benchmark-path "browse.scm")
(define churchnums-benchmark-path "churchnums.scm")
(define collatz-benchmark-path "collatz.scm")
(define cpstak-benchmark-path "cpstak.scm")
(define eta-benchmark-path "eta.scm")
(define fac-benchmark-path "fac.scm")
(define fib-benchmark-path "fib.scm")
(define kcfa-2-benchmark-path "kcfa2.scm")
(define kcfa-3-benchmark-path "kcfa3.scm")
(define kcfa-worst-case-40-benchmark-path "kcfa-worst-case-40.scm")
(define loop-2-benchmark-path "loop2.scm")
(define meta-circ-benchmark-path "meta-circ.scm")
(define mj09-benchmark-path "mj09.scm")
(define nqueens-benchmark-path "nqueens.scm")
(define nqueens-2-benchmark-path "nqueens 2.scm")
(define pnpoly-benchmark-path "pnpoly.scm")
(define primtest-benchmark-path "primtest.scm")
(define regex-benchmark-path "regex.scm")
(define rotate-benchmark-path "rotate.scm")
(define rotate-2-benchmark-path "rotate 2.scm")
(define rsa-benchmark-path "rsa.scm")
(define sat-benchmark-path "sat.scm")
(define scheme2c-benchmark-path "scheme2c.scm")
(define scheme2java-benchmark-path "scm2java.scm")
(define simple-guard-trace-merging-benchmark-path "simple guard-trace merging.scm")
(define simplified-trace-explosion-benchmark-path "simplified trace-explosion.scm")
(define solovay-strassen-benchmark-path "solovay-strassen.scm")
(define trace-explosion-benchmark-path "trace-explosion.scm")
(define trace-explosion-not-random-benchmark-path "trace-explosion not random.scm")
(define tree-sort-benchmark-path "tree-sort.scm")
(define towers-of-hanoi-benchmark-path "towers-of-hanoi.scm")



;
; Benchmarking
;

(define (output text)
  (display text)
  (write-to-output-file text))

(define (output-newline)
  (output #\newline))

(define (output-metric metric-name result)
  (output "Metric ") (output metric-name) (output " got result ") (output result)
  (output-newline))

(define (output-result benchmark-file evaluator result)
  (output "=> ") (output evaluator) (output " evaluated ") (output benchmark-file) (output " and got result: ") (output result)
  (output-newline)
  (output-newline))

(define (overwrite-input-file new-benchmark-path)
  (let* ((input-port (open-input-file new-benchmark-path))
         (output-port (open-output-file BENCHMARK_INPUT_PATH #:exists 'replace))
         (benchmark-file-contents (read input-port)))
    (write benchmark-file-contents output-port)
    (close-input-port input-port)
    (close-output-port output-port)))

(define (run-trace-metrics)
  (let ((total-number-of-traces-metric-name "total-number-of-traces")
        (average-trace-length-metric-name "average-trace-length")
        (trace-duplication-metric-name "trace-duplicity")
        (trace-executions-metric-name "trace-executions"))
    (define (run-total-number-of-traces-metric)
      (output-metric total-number-of-traces-metric-name (calculate-total-number-of-traces)))
    (define (run-average-trace-length-metric)
      (output-metric average-trace-length-metric-name (calculate-average-trace-length)))
    (define (run-trace-executions-metric)
      (define (show-times-executed result)
        (output "label-traces ") (output (apply + (map (lambda (executions) (length (cdr executions)))
                                                       (car result))))
        (output-newline)
        (output "guard-traces ") (output (apply + (map (lambda (executions) (length (cdr executions)))
                                                       (cadr result))))
        (output-newline)
        (output "mp-tail-traces ") (output (apply + (map (lambda (executions) (length (cdr executions)))
                                                         (caddr result))))
        (output-newline))
      (output "Metric ") (output trace-executions-metric-name) (output " calculated results: ") (output-newline)
      (show-times-executed (get-trace-executions))
      (output-newline))
    (define (run-trace-duplication-metric)
      (let* ((trace-duplication-metric-result (calculate-trace-duplication)))
        (if (pair? trace-duplication-metric-result)
            (let ((root-expression (car trace-duplication-metric-result))
                  (all-ast-nodes (cadr trace-duplication-metric-result))
                  (average #f)
                  (variation #f)
                  (standard-deviation #f)
                  (min-trace-duplication +inf.0)
                  (max-trace-duplication -inf.0))
              (define (process-ast-nodes-list ast-nodes)
                (let ((length 0.0)
                      (sum-1 0.0)
                      (sum-2 0.0))
                  (for ((ast-node ast-nodes))
                    (let ((ast-node-trace-duplication (vector-ref ast-node 1)))
                      (when (> ast-node-trace-duplication 0)
                        (set! length (+ length 1))
                        (set! min-trace-duplication (min min-trace-duplication ast-node-trace-duplication))
                        (set! max-trace-duplication (max max-trace-duplication ast-node-trace-duplication))
                        (set! sum-1 (+ ast-node-trace-duplication sum-1))
                        (set! sum-2 (+ (sqr ast-node-trace-duplication) sum-2)))))
                  (set! average (/ sum-1 length))
                  (set! variation (- (/ sum-2 length) (sqr average)))
                  (set! standard-deviation (sqrt variation))))
              (process-ast-nodes-list all-ast-nodes)
              ;(display all-ast-nodes) (newline)
              (display root-expression) (newline)
              (output-metric trace-duplication-metric-name (list (cons 'average average)
                                                                 (cons 'variation variation)
                                                                 (cons 'standard-deviation standard-deviation)
                                                                 (cons 'minimum-trace-duplication min-trace-duplication)
                                                                 (cons 'maximum-trace-duplication max-trace-duplication))))
            (output-metric trace-duplication-metric-name trace-duplication-metric-result))))
    (run-total-number-of-traces-metric)
    (run-average-trace-length-metric)
    (run-trace-executions-metric)
    (run-trace-duplication-metric)
    (output-newline)
    (output-newline)))

(define (run-benchmark benchmark-path)
  (let* ((s-exp (file->value benchmark-path))
         (tracing-interpreter-name "Tracing interpreter")
         (rec-slip-interpreter-normal-name "Recursive Slip interpreter (normal)")
         (rec-slip-interpreter-traced-name "Recursive Slip interpreter (traced)")
         (rec-slip-interpreter-traced-no-merging-name "Recursive Slip interpreter (traced no merging)"))
    (define (run-interpreter interpreter-start-function interpreter-name)
      (output-interpreter-start interpreter-name)
      (let ((value (interpreter-start-function)))
        (output-result-from-evaluator interpreter-name value)))
    (define (run-interpreter-timed interpreter-start-function interpreter-name)
      (let ((start-ms (current-milliseconds)))
        (run-interpreter interpreter-start-function interpreter-name)
        (let* ((end-ms (current-milliseconds))
               (delta-ms (- end-ms start-ms)))
          ;; Safeguard for 32-bit systems
          (if (> delta-ms 0)
              (begin (output "Time taken for ") (output interpreter-name) (output ": ") (output delta-ms) (output "ms") (output-newline))
              (error "Timing the run of the interpreter failed: calculated a negative time" delta-ms)))))
    (define (output-result-from-evaluator evaluator result)
      (output-result benchmark-path evaluator result))
    (define (output-benchmark-start)
      (output "---------- BENCHMARK STARTED: ") (output benchmark-path) (output " ----------")
      (output-newline)
      (output-newline))
    (define (output-benchmark-end)
      (output "---------- BENCHMARK FINISHED: ") (output benchmark-path) (output " ----------")
      (output-newline))
    (define (output-interpreter-start interpreter-name)
      (output "interpreter started: ") (output interpreter-name)
      (newline))
    (define (run-tracing-interpreter)
      (run-interpreter (lambda () (run (inject s-exp))) tracing-interpreter-name))
    (define (run-rec-slip-interpreter-normal)
      (run-interpreter (lambda () (eval rec-slip-interpreter-normal-exp)) rec-slip-interpreter-normal-name))
    (define (run-rec-slip-interpreter-normal-meta-interpreted)
      (run-interpreter (lambda () (eval rec-slip-interpreter-normal-exp)) rec-slip-interpreter-normal-name))
    (define (run-rec-slip-interpreter-traced-meta-interpreted)
      (run-interpreter-timed (lambda () (run (inject rec-slip-interpreter-traced-merging-duplication-exp))) rec-slip-interpreter-traced-name))
    (define (run-rec-slip-interpreter-traced-no-merging-meta-interpreted)
      (run-interpreter-timed (lambda () (run (inject rec-slip-interpreter-traced-no-merging-duplication-exp))) rec-slip-interpreter-traced-no-merging-name))
    
    (output-benchmark-start)
    (overwrite-input-file benchmark-path)
    
    (run-tracing-interpreter)
    (run-rec-slip-interpreter-normal)
    
    (run-rec-slip-interpreter-traced-meta-interpreted)
    (run-trace-metrics)
    
    (run-rec-slip-interpreter-traced-no-merging-meta-interpreted)
    (run-trace-metrics)
    
    (output-benchmark-end)))

(define (run-benchmarks n benchmarks)
  (for ((i (range n)))
    (set-pseudo-random-generator! (current-pseudo-random-generator))
    (for ((benchmark benchmarks))
      (run-benchmark benchmark)))
  "Finished!")

